# Data cleaning scripts. Ukraine CO RAM
Data cleaning scripts, Ukraine CO RAM

## Logic cross-checks

Are meant for identifying logic flaws in submissions (categorical variables) and returning them for case-to-case revision and/or clarification with field teams.

As an input file, the logic frame for logic checks is needed. It has to indicate what combinations of values in selected variables constitute the survey logic fallacy.

- *"target_var"* - variable to be checked
- *"target_val"* - value in target_var that has to be checked
- *"cross_var"* - variable which target_var should be crosschecked with
- *"cross_val"* - value in cross_var, target_val should not cooccure with
- *"sign"* - sign to evaluate (for checks involving categorical vs numeric)

Variables from the logic frame should be present in the dataset.

### Categorical cross_checks

**get_logic_errors_categorical()**

Logic cross-checks between two categorical variables.

Arguments:

- *data* dataframe to be checked
- *logic_frame* dataframe with logic frame (with aforementioned variables)
- *id_col* character value, name of column, containing unique ids
- *enum_col="complementary_col"* character, name of coulumn, containing enumerator's id (optional)
- *date_col="complementary_col"*, character, name of column, containing date (optional)
- *enum_com_col="complementary_col"*, character, name of column, containing enumerator's comment (optional)
- *index_col="complementary_col"* character, name of column with index (for datasets, containing loops within submissions)

Value:

Logic issues frame with two additional empty columns "variable_to_change" and "correct_value"

Example:

``` {r}
get_logic_errors_categorical(data = main_ds, logic_frame = logic_checks, id_col = "_uuid", enum_col = "enum_id", date_col = "date_survey", enum_com_col = "N_1_enumerator_comment_note")
```
### Categorical to numeric cross-checks

**get_logic_errors_categorical_numeric()**

Logic cross-checks between categorical and numeric variables.
For this checks, the logic frame should contain the "sign" column.

Arguments:

- *data* dataframe to be checked
- *logic_frame* dataframe with logic frame (with aforementioned variables)
- *id_col* character value, name of column, containing unique ids
- *enum_col="complementary_col"* character, name of coulumn, containing enumerator's id (optional)
- *date_col="complementary_col"*, character, name of column, containing date (optional)
- *enum_com_col="complementary_col"*, character, name of column, containing enumerator's comment (optional)
- *index_col="complementary_col"* character, name of column with index (for datasets, containing loops within submissions)

Value:

Logic issues frame with two additional empty columns "variable_to_change" and "correct_value"

Example:

```{r}
get_logic_errors_categorical_numeric(data = loop_3, logic_frame = logic_checks, id_col = "relationship_instance", index_col = "_index")
```

### Apply adjusted logic issues frame to the dataset

**get_logic_applied()**

Applies corrected values from logic errors frame (generated by get_logic_errors_categorical() or get_logic_errors_categorical_numeric() and with "variable_to_change" and "correct_value" fields filled in) to a dataframe.

Empty "correct_value" rows are replaced to NA. If the issue is not considered for correction, it should be deleted from the logic issues frame.

Arguments:

- *data* dataframe, data to be changed
- *logic_frame_issues* dataframe, logic issues frame with corrected values
- *idvar* variable with unique submission id (either id of submission or index from a loop data set)

Value

Dataframe, containing dataset with corrected values

Example:

```{r}
get_logic_applied(main_ds, logic_issues_main |> filter(!is.na(variable_to_change)), idvar="_uuid")
```

